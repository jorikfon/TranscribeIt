# План рефакторинга TranscribeIt

## Общий обзор

TranscribeIt — профессиональное приложение для транскрибации стерео телефонных записей на macOS с использованием WhisperKit. Проект находится на ранней стадии развития, но уже демонстрирует хорошую архитектурную основу. Данный документ содержит рекомендации по рефакторингу для улучшения качества кода, поддерживаемости и соответствия современным паттернам разработки Swift-приложений.

---

## 1. Архитектурные улучшения

### 1.1 Разделение ответственности (SRP)

**Проблема:** Некоторые классы выполняют слишком много задач

**Примеры:**
- `MainWindow.swift` (1394 строки) объединяет NSWindow, ViewModel, SwiftUI views, timeline mapping и UI компоненты
- `FileTranscriptionService.swift` (711 строк) обрабатывает загрузку аудио, разделение каналов, VAD, транскрипцию и построение контекста

**Рекомендации:**
```swift
// Текущая структура:
MainWindow.swift
  ├── MainWindow (NSWindow)
  ├── FileTranscriptionViewModel
  ├── FileTranscriptionView
  ├── TimelineSyncedDialogueView
  ├── CompressedTimelineMapper
  └── AudioPlayerView

// Предлагаемая структура:
Sources/UI/Windows/
  └── MainWindow.swift (только NSWindow)
Sources/UI/ViewModels/
  └── FileTranscriptionViewModel.swift
Sources/UI/Views/
  ├── FileTranscriptionView.swift
  ├── TimelineView.swift
  └── AudioPlayerView.swift
Sources/Utils/Timeline/
  └── TimelineMapper.swift
```

**Детали рефакторинга:**
- Выделить `CompressedTimelineMapper` в отдельный файл как часть утилит работы с timeline
- Разделить `FileTranscriptionView` на более мелкие компоненты
- Вынести `FileTranscriptionViewModel` в отдельный файл

### 1.2 Dependency Injection

**Проблема:** Жесткая связанность компонентов через синглтоны

**Примеры:**
```swift
// WhisperService.swift:10
private let vocabularyManager = VocabularyManager.shared

// FileTranscriptionService.swift:189
let settings = UserSettings.shared

// MainWindow.swift:258
@ObservedObject private var modelManager = ModelManager.shared
@ObservedObject private var userSettings = UserSettings.shared
```

**Рекомендации:**
```swift
// Вместо:
class WhisperService {
    private let vocabularyManager = VocabularyManager.shared
}

// Использовать:
class WhisperService {
    private let vocabularyManager: VocabularyManagerProtocol

    init(vocabularyManager: VocabularyManagerProtocol = VocabularyManager.shared) {
        self.vocabularyManager = vocabularyManager
    }
}

// Определить протоколы для всех сервисов:
protocol VocabularyManagerProtocol {
    func correctTranscription(_ text: String) -> String
    func loadDictionary(id: String) -> [String]
}
```

**Преимущества:**
- Улучшенная тестируемость (можно подставлять моки)
- Явные зависимости
- Упрощенное unit-тестирование

### 1.3 Архитектурный паттерн MVVM

**Проблема:** Неполное разделение View и ViewModel

**Примеры:**
```swift
// MainWindow.swift:485 - бизнес-логика в View
private func selectAudioFile() {
    let panel = NSOpenPanel()
    panel.title = "Select Stereo Audio File"
    // ... 20+ строк настройки и обработки
}

// MainWindow.swift:519 - бизнес-логика перезапуска
private func retranscribeCurrentFile() {
    guard let fileURL = viewModel.currentFileURL else { return }
    modelManager.saveCurrentModel(selectedModel)
    userSettings.vadAlgorithmType = selectedVADAlgorithm
    // ...
}
```

**Рекомендации:**
```swift
// Вынести в ViewModel:
class FileTranscriptionViewModel {
    func selectFile() -> URL? {
        let panel = NSOpenPanel()
        // конфигурация
        return panel.url
    }

    func retranscribe(with settings: TranscriptionSettings) {
        // сохранение настроек и перезапуск
    }
}

// Упростить View:
struct FileTranscriptionView: View {
    func selectNewFile() {
        if let url = viewModel.selectFile() {
            onStartTranscription?([url])
        }
    }
}
```

---

## 2. Управление состоянием

### 2.1 Множественные @Published свойства

**Проблема:** Сложность отслеживания состояния через множество отдельных свойств

**Пример (AudioPlayerManager.swift:7-15):**
```swift
@Published public var isPlaying: Bool = false
@Published public var currentTime: TimeInterval = 0
@Published public var duration: TimeInterval = 0
@Published public var volume: Float = 1.0
@Published public var volumeBoost: Float = 1.0
@Published public var playbackRate: Float = 1.0
@Published public var monoMode: Bool = true
@Published public var pauseOtherPlayersEnabled: Bool = true
```

**Рекомендации:**
```swift
// Объединить в структуру состояния:
struct AudioPlayerState {
    var playback: PlaybackState
    var audio: AudioState
    var settings: AudioSettings
}

struct PlaybackState {
    var isPlaying: Bool = false
    var currentTime: TimeInterval = 0
    var duration: TimeInterval = 0
}

struct AudioState {
    var volume: Float = 1.0
    var volumeBoost: Float = 1.0
}

struct AudioSettings {
    var playbackRate: Float = 1.0
    var monoMode: Bool = true
    var pauseOtherPlayersEnabled: Bool = true
}

class AudioPlayerManager: ObservableObject {
    @Published public var state = AudioPlayerState()
}
```

**Преимущества:**
- Логическая группировка связанных данных
- Упрощенная валидация состояния
- Атомарные изменения состояния

### 2.2 Неявное управление асинхронными операциями

**Проблема:** Отсутствие централизованного управления задачами транскрипции

**Пример (AppDelegate.swift:229):**
```swift
private func performTranscription(files: [URL], window: MainWindow) {
    Task {
        // Ждём загрузки модели (244-268)
        while isModelLoading {
            try? await Task.sleep(nanoseconds: 100_000_000)
        }

        // Транскрибация (279-319)
        let dialogue = try await batchService.transcribe(url: file)
        // ...
    }
}
```

**Рекомендации:**
```swift
// Создать менеджер задач транскрипции:
actor TranscriptionTaskManager {
    private var currentTask: Task<Void, Never>?

    func startTranscription(file: URL, service: TranscriptionService) async throws -> DialogueTranscription {
        // Отменить предыдущую задачу
        currentTask?.cancel()

        // Создать новую задачу
        let task = Task {
            return try await service.transcribe(file: file)
        }
        currentTask = task

        return try await task.value
    }

    func cancel() {
        currentTask?.cancel()
    }
}
```

---

## 3. Обработка ошибок

### 3.1 Использование общих ошибок

**Проблема:** Слабая типизация ошибок

**Пример (FileTranscriptionService.swift:252):**
```swift
throw NSError(domain: "FileTranscriptionService", code: 1,
             userInfo: [NSLocalizedDescriptionKey: "BatchTranscriptionService не инициализирован"])
```

**Рекомендации:**
```swift
// Определить строго типизированные ошибки:
enum TranscriptionError: LocalizedError {
    case serviceNotInitialized(String)
    case audioLoadFailed(URL, underlying: Error)
    case noAudioTrack(URL)
    case modelNotReady
    case transcriptionTimeout
    case invalidFileFormat(URL, expected: [String])

    var errorDescription: String? {
        switch self {
        case .serviceNotInitialized(let service):
            return "Service '\(service)' is not initialized"
        case .audioLoadFailed(let url, let error):
            return "Failed to load audio from '\(url.lastPathComponent)': \(error.localizedDescription)"
        case .noAudioTrack(let url):
            return "No audio track found in '\(url.lastPathComponent)'"
        case .modelNotReady:
            return "Whisper model is not ready"
        case .transcriptionTimeout:
            return "Transcription timed out after 60 seconds"
        case .invalidFileFormat(let url, let expected):
            return "Invalid file format for '\(url.lastPathComponent)'. Expected: \(expected.joined(separator: ", "))"
        }
    }

    var recoverySuggestion: String? {
        switch self {
        case .modelNotReady:
            return "Please wait for the model to finish loading"
        case .invalidFileFormat(_, let expected):
            return "Please use one of the supported formats: \(expected.joined(separator: ", "))"
        default:
            return nil
        }
    }
}

// Использование:
throw TranscriptionError.serviceNotInitialized("BatchTranscriptionService")
```

### 3.2 Отсутствие обработки граничных случаев

**Проблема:** Недостаточная проверка входных данных

**Пример (FileTranscriptionService.swift:344):**
```swift
private func loadAudio(from url: URL) async throws -> [Float] {
    let asset = AVAsset(url: url)

    guard let audioTrack = try await asset.loadTracks(withMediaType: .audio).first else {
        throw FileTranscriptionError.noAudioTrack
    }

    // Отсутствует проверка:
    // - Поддерживается ли формат файла?
    // - Корректен ли sample rate?
    // - Не поврежден ли файл?
    // - Не слишком ли большой файл?
```

**Рекомендации:**
```swift
private func loadAudio(from url: URL) async throws -> [Float] {
    // 1. Проверка доступности файла
    guard FileManager.default.fileExists(atPath: url.path) else {
        throw TranscriptionError.fileNotFound(url)
    }

    // 2. Проверка размера файла
    let fileSize = try FileManager.default.attributesOfItem(atPath: url.path)[.size] as? Int64 ?? 0
    let maxSize: Int64 = 500 * 1024 * 1024 // 500 MB
    guard fileSize <= maxSize else {
        throw TranscriptionError.fileTooLarge(url, size: fileSize, max: maxSize)
    }

    // 3. Проверка формата
    let asset = AVAsset(url: url)
    let tracks = try await asset.loadTracks(withMediaType: .audio)

    guard let audioTrack = tracks.first else {
        throw TranscriptionError.noAudioTrack(url)
    }

    // 4. Валидация audio track
    let formatDescriptions = try await audioTrack.load(.formatDescriptions)
    guard !formatDescriptions.isEmpty else {
        throw TranscriptionError.invalidAudioFormat(url, reason: "No format descriptions")
    }

    // ... продолжение загрузки
}
```

---

## 4. Производительность и оптимизация

### 4.1 Избыточная загрузка аудио

**Проблема:** Многократная загрузка и конвертация одного и того же файла

**Пример:**
```swift
// FileTranscriptionService.swift:344 - загрузка mono
private func loadAudio(from url: URL) async throws -> [Float]

// FileTranscriptionService.swift:564 - загрузка stereo
private func loadAudioStereo(from url: URL) async throws -> [[Float]]

// AudioPlayerManager.swift:71 - еще одна загрузка для воспроизведения
public func loadAudio(from url: URL) throws
```

**Рекомендации:**
```swift
// Создать кэш аудио-данных:
actor AudioCache {
    private var cache: [URL: CachedAudio] = [:]

    struct CachedAudio {
        let samples: [Float]
        let stereoChannels: ([Float], [Float])?
        let sampleRate: Double
        let duration: TimeInterval
        let loadedAt: Date
    }

    func loadAudio(from url: URL) async throws -> CachedAudio {
        // Проверяем кэш
        if let cached = cache[url],
           Date().timeIntervalSince(cached.loadedAt) < 300 { // 5 минут
            LogManager.app.debug("Using cached audio for \(url.lastPathComponent)")
            return cached
        }

        // Загружаем новый
        let audio = try await loadFromDisk(url)
        cache[url] = audio
        return audio
    }

    func clearCache() {
        cache.removeAll()
    }
}
```

### 4.2 Блокирование UI потока

**Проблема:** Длительные операции могут блокировать UI

**Пример (MainWindow.swift:432):**
```swift
.onAppear {
    // Загружаем аудио файл при появлении
    if let fileURL = transcription.fileURL {
        do {
            try viewModel.audioPlayer.loadAudio(from: fileURL)
        } catch {
            LogManager.app.failure("Ошибка загрузки аудио", error: error)
        }
    }
}
```

**Рекомендации:**
```swift
.task {
    // Используем .task вместо .onAppear для async операций
    if let fileURL = transcription.fileURL {
        await viewModel.loadAudioInBackground(from: fileURL)
    }
}

// В ViewModel:
func loadAudioInBackground(from url: URL) async {
    do {
        // Показываем индикатор загрузки
        await MainActor.run {
            self.isLoadingAudio = true
        }

        // Загружаем в фоне
        try await audioPlayer.loadAudio(from: url)

        await MainActor.run {
            self.isLoadingAudio = false
        }
    } catch {
        await MainActor.run {
            self.audioLoadError = error
            self.isLoadingAudio = false
        }
    }
}
```

### 4.3 Неэффективная работа с большими массивами

**Проблема:** Копирование больших массивов аудио-данных

**Пример (FileTranscriptionService.swift:618):**
```swift
private func extractChannel(from stereoData: [[Float]], channel: Int) -> [Float] {
    guard let interleavedSamples = stereoData.first else { return [] }

    var channelSamples: [Float] = []
    channelSamples.reserveCapacity(interleavedSamples.count / 2)

    stride(from: channel, to: interleavedSamples.count, by: 2).forEach { index in
        channelSamples.append(interleavedSamples[index])
    }

    return channelSamples
}
```

**Рекомендации:**
```swift
// Использовать UnsafeBufferPointer для нулевого копирования:
private func extractChannel(from stereoData: [[Float]], channel: Int) -> [Float] {
    guard let interleavedSamples = stereoData.first else { return [] }

    return interleavedSamples.withUnsafeBufferPointer { buffer in
        var channelSamples = [Float]()
        channelSamples.reserveCapacity(buffer.count / 2)

        for i in stride(from: channel, to: buffer.count, by: 2) {
            channelSamples.append(buffer[i])
        }

        return channelSamples
    }
}

// Или использовать vDSP для векторизации:
import Accelerate

private func extractChannelVectorized(from stereoData: [[Float]], channel: Int) -> [Float] {
    guard let interleavedSamples = stereoData.first else { return [] }

    var channelSamples = [Float](repeating: 0, count: interleavedSamples.count / 2)

    interleavedSamples.withUnsafeBufferPointer { source in
        channelSamples.withUnsafeMutableBufferPointer { dest in
            // Используем vDSP для эффективного извлечения канала
            vDSP_vsadd(
                source.baseAddress! + channel,
                2,  // stride
                [0],
                dest.baseAddress!,
                1,
                vDSP_Length(dest.count)
            )
        }
    }

    return channelSamples
}
```

---

## 5. SwiftUI Best Practices

### 5.1 Избыточная вложенность View

**Проблема:** Сложные View с глубокой вложенностью

**Пример (MainWindow.swift:271-477):**
```swift
var body: some View {
    VStack(spacing: 0) {
        HStack {
            // 40+ строк заголовка
        }
        Divider()
        if showSettings {
            TranscriptionSettingsPanel(/* ... */)  // Еще 100+ строк
        }
        if viewModel.state == .processing {
            ProgressView(/* ... */)
        }
        if let transcription = currentTranscription {
            VStack(spacing: 0) {
                // 50+ строк контента
            }
        } else {
            VStack(spacing: 20) {
                // 30+ строк пустого состояния
            }
        }
    }
}
```

**Рекомендации:**
```swift
// Разбить на композируемые компоненты:
struct FileTranscriptionView: View {
    var body: some View {
        VStack(spacing: 0) {
            HeaderView(viewModel: viewModel)
            Divider()

            if showSettings {
                SettingsPanel(/* ... */)
                Divider()
            }

            ContentView(transcription: currentTranscription, viewModel: viewModel)
        }
    }
}

struct HeaderView: View {
    @ObservedObject var viewModel: FileTranscriptionViewModel

    var body: some View {
        HStack {
            FileNameLabel(fileName: viewModel.currentFile)
            Spacer()
            StatusIndicators(viewModel: viewModel)
            ActionButtons(viewModel: viewModel)
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
    }
}

struct ContentView: View {
    let transcription: FileTranscription?
    @ObservedObject var viewModel: FileTranscriptionViewModel

    var body: some View {
        if let transcription = transcription {
            TranscriptionContentView(transcription: transcription, viewModel: viewModel)
        } else {
            EmptyStateView()
        }
    }
}
```

### 5.2 Отсутствие ViewBuilder паттерна

**Проблема:** Дублирование логики построения View

**Пример (MainWindow.swift:289-345):**
```swift
// Дублирование условной логики для отображения индикаторов
if let loadingStatus = viewModel.modelLoadingStatus, loadingStatus != "Model ready" {
    HStack(spacing: 4) { /* ... */ }
}

if !viewModel.modelName.isEmpty {
    HStack(spacing: 4) { /* ... */ }
}

if !userSettings.transcriptionLanguage.isEmpty {
    HStack(spacing: 4) { /* ... */ }
} else {
    HStack(spacing: 4) { /* ... */ }
}
```

**Рекомендации:**
```swift
// Использовать ViewBuilder для переиспользуемых компонентов:
struct StatusIndicator: View {
    let icon: String
    let text: String
    let color: Color

    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: icon)
                .font(.system(size: 10))
                .foregroundColor(color)
            Text(text)
                .font(.system(size: 10))
                .foregroundColor(.secondary)
        }
    }
}

// Использование:
Group {
    if let status = viewModel.modelLoadingStatus, status != "Model ready" {
        StatusIndicator(icon: "cpu", text: status, color: .orange)
    }

    if !viewModel.modelName.isEmpty {
        StatusIndicator(icon: "cpu", text: viewModel.modelName, color: .blue)
    }

    StatusIndicator(
        icon: "globe",
        text: userSettings.transcriptionLanguage.isEmpty ? "Auto" : userSettings.transcriptionLanguage.uppercased(),
        color: .purple
    )
}
```

### 5.3 Императивное управление состоянием

**Проблема:** Использование `withAnimation` для каждого изменения

**Пример (MainWindow.swift:542):**
```swift
withAnimation {
    showSettings = false
}
```

**Рекомендации:**
```swift
// Использовать .animation() модификатор для декларативной анимации:
@State private var showSettings: Bool = false

VStack {
    // ...
}
.animation(.easeInOut(duration: 0.2), value: showSettings)

// Или использовать transition для сложных анимаций:
if showSettings {
    SettingsPanel()
        .transition(.move(edge: .top).combined(with: .opacity))
}
```

---

## 6. Код-стайл и читаемость

### 6.1 Магические числа

**Проблема:** Хардкод значений без объяснения

**Примеры:**
```swift
// MainWindow.swift:690
private let minGapToCompress: TimeInterval = 0.5
private let compressedGapDisplay: TimeInterval = 0.15

// MainWindow.swift:904
let timeTolerance: TimeInterval = 0.5

// MainWindow.swift:966
return gap > 1.0 ? gap : nil

// CompactTurnCard.swift:1132
min(max(CGFloat(turn.duration) * durationBarScale, 10), 60)
```

**Рекомендации:**
```swift
// Определить константы с понятными именами:
private enum TimelineConstants {
    static let minSilenceGapToCompress: TimeInterval = 0.5  // Минимальная тишина для сжатия
    static let compressedGapDisplayDuration: TimeInterval = 0.15  // Длительность сжатого gap
    static let turnSyncTolerance: TimeInterval = 0.5  // Допуск синхронизации реплик
    static let significantSilenceThreshold: TimeInterval = 1.0  // Порог значимой тишины
}

private enum TurnCardConstants {
    static let minDurationBarHeight: CGFloat = 10
    static let maxDurationBarHeight: CGFloat = 60
}

// Использование:
if gap > TimelineConstants.significantSilenceThreshold {
    return gap
}

let height = min(
    max(CGFloat(turn.duration) * durationBarScale, TurnCardConstants.minDurationBarHeight),
    TurnCardConstants.maxDurationBarHeight
)
```

### 6.2 Длинные методы

**Проблема:** Методы выполняют слишком много действий

**Пример (FileTranscriptionService.swift:438-535):**
```swift
private func transcribeStereoAsDialogue(url: URL) async throws -> DialogueTranscription {
    // 1. Загрузка стерео (442-443)
    let stereoSamples = try await loadAudioStereo(from: url)

    // 2. Разделение каналов (445-446)
    let leftChannel = extractChannel(from: stereoSamples, channel: 0)
    let rightChannel = extractChannel(from: stereoSamples, channel: 1)

    // 3. VAD анализ (452-458)
    let leftSegments = detectSegments(in: leftChannel)
    let rightSegments = detectSegments(in: rightChannel)

    // 4. Объединение сегментов (461-483)
    var allSegments: [ChannelSegment] = []
    // ...

    // 5. Сортировка (486)
    allSegments.sort(by: { $0.segment.startTime < $1.segment.startTime })

    // 6. Транскрипция (494-530)
    for channelSegment in allSegments {
        // 40+ строк обработки
    }

    return DialogueTranscription(turns: turns, isStereo: true, totalDuration: totalDuration)
}
```

**Рекомендации:**
```swift
// Разбить на более мелкие методы с четкой ответственностью:

private func transcribeStereoAsDialogue(url: URL) async throws -> DialogueTranscription {
    let (leftChannel, rightChannel, totalDuration) = try await prepareStereoChanels(from: url)
    let allSegments = try await detectAndMergeStereoSegments(left: leftChannel, right: rightChannel)
    let turns = try await transcribeSegmentsInOrder(allSegments, fileName: url.lastPathComponent)

    return DialogueTranscription(turns: turns, isStereo: true, totalDuration: totalDuration)
}

private func prepareStereoChanels(from url: URL) async throws -> (left: [Float], right: [Float], duration: TimeInterval) {
    let stereoSamples = try await loadAudioStereo(from: url)
    let leftChannel = extractChannel(from: stereoSamples, channel: 0)
    let rightChannel = extractChannel(from: stereoSamples, channel: 1)
    let totalDuration = TimeInterval(leftChannel.count) / 16000.0

    return (leftChannel, rightChannel, totalDuration)
}

private func detectAndMergeStereoSegments(left: [Float], right: [Float]) async throws -> [ChannelSegment] {
    let leftSegments = detectSegments(in: left)
    let rightSegments = detectSegments(in: right)

    var allSegments = leftSegments.map { createChannelSegment($0, from: left, speaker: .left) }
    allSegments += rightSegments.map { createChannelSegment($0, from: right, speaker: .right) }

    return allSegments.sorted { $0.segment.startTime < $1.segment.startTime }
}

private func transcribeSegmentsInOrder(_ segments: [ChannelSegment], fileName: String) async throws -> [DialogueTranscription.Turn] {
    var turns: [DialogueTranscription.Turn] = []
    let totalSegments = segments.count

    for (index, segment) in segments.enumerated() {
        if let turn = try await transcribeSegment(segment, context: turns) {
            turns.append(turn)
            updateProgress(current: index + 1, total: totalSegments, fileName: fileName, turns: turns)
        }
    }

    return turns
}
```

### 6.3 Несогласованное именование

**Проблема:** Отсутствие единого стиля именования

**Примеры:**
```swift
// Разные стили для похожих сущностей:
func transcribeFile(at url: URL)           // "at url"
func loadAudio(from url: URL)              // "from url"
func detectSegments(in samples: [Float])   // "in samples"

// Несогласованные префиксы:
var isPlaying: Bool
var pauseOtherPlayersEnabled: Bool  // Должно быть isOtherPlayersEnabled

// Смесь русских и английских названий:
func formatTimestamp(_ seconds: TimeInterval)
func форматироватьВремя(_ секунды: TimeInterval)  // в комментариях
```

**Рекомендации:**
```swift
// Придерживаться единого стиля предлогов:
func transcribeFile(from url: URL)         // Изменить на "from"
func loadAudio(from url: URL)              // Оставить
func detectSegments(in samples: [Float])   // Оставить

// Использовать согласованные префиксы для Bool:
var isPlaying: Bool
var isPauseOtherPlayersEnabled: Bool       // Добавить префикс "is"

// Все имена переменных/функций на английском:
// Комментарии могут быть на русском для локальной команды
```

---

## 7. Тестирование

### 7.1 Отсутствие unit-тестов

**Проблема:** В проекте нет unit-тестов

**Рекомендации:**
```swift
// Создать структуру для тестов:
TranscribeItTests/
  ├── Services/
  │   ├── WhisperServiceTests.swift
  │   ├── FileTranscriptionServiceTests.swift
  │   └── BatchTranscriptionServiceTests.swift
  ├── Utils/
  │   ├── VADTests.swift
  │   ├── AudioNormalizerTests.swift
  │   └── TimelineMapperTests.swift
  └── ViewModels/
      └── FileTranscriptionViewModelTests.swift

// Пример теста:
import XCTest
@testable import TranscribeItCore

final class TimelineMapperTests: XCTestCase {
    func testSilenceGapDetection() {
        // Given
        let turns = [
            DialogueTranscription.Turn(speaker: .left, text: "Hello", startTime: 0, endTime: 2),
            DialogueTranscription.Turn(speaker: .right, text: "World", startTime: 5, endTime: 7)
        ]

        // When
        let mapper = CompressedTimelineMapper(turns: turns)

        // Then
        XCTAssertEqual(mapper.silenceGaps.count, 1)
        XCTAssertEqual(mapper.silenceGaps[0].duration, 3.0)
    }

    func testVisualPositionMapping() {
        // Given
        let turns = [
            DialogueTranscription.Turn(speaker: .left, text: "Test", startTime: 0, endTime: 1),
            DialogueTranscription.Turn(speaker: .left, text: "Test2", startTime: 10, endTime: 11)
        ]
        let mapper = CompressedTimelineMapper(turns: turns)

        // When
        let visualPosition = mapper.visualPosition(for: 10.0)

        // Then
        XCTAssertLessThan(visualPosition, 10.0)  // Gap должен быть сжат
    }
}
```

### 7.2 Сложность тестирования из-за синглтонов

**Проблема:** Невозможность изолированного тестирования

**Решение:** Как описано в разделе 1.2 (Dependency Injection), использовать протоколы и инъекцию зависимостей

---

## 8. Документация

### 8.1 Недостаточная документация API

**Проблема:** Многие публичные методы не документированы

**Примеры:**
```swift
// WhisperService.swift:136
public func transcribeChunk(audioSamples: [Float]) async throws -> String {
    // Нет документации о том, что это "быстрая транскрипция"
    // Нет описания параметров
    // Нет примера использования
}

// FileTranscriptionService.swift:227
public func transcribeFileWithDialogue(at url: URL) async throws -> DialogueTranscription {
    // Нет документации
}
```

**Рекомендации:**
```swift
/// Быстрая транскрипция аудио-чанка для real-time отображения
///
/// Использует упрощенные настройки распознавания для минимизации задержки.
/// Не применяет Quality Enhancement режим. Оптимизирован для скорости.
///
/// - Parameter audioSamples: Массив Float32 аудио сэмплов в формате 16kHz mono
/// - Returns: Распознанный текст с применением словарных коррекций
/// - Throws: `WhisperError.modelNotLoaded` если модель не загружена
///
/// - Note: Для финальной транскрипции используйте `transcribe(audioSamples:contextPrompt:)`
///
/// ## Example
/// ```swift
/// let samples: [Float] = // ... audio data
/// let text = try await whisperService.transcribeChunk(audioSamples: samples)
/// print("Recognized: \(text)")
/// ```
public func transcribeChunk(audioSamples: [Float]) async throws -> String {
    // ...
}
```

---

## 9. Безопасность и приватность

### 9.1 Логирование конфиденциальных данных

**Проблема:** Логирование текста транскрипций может содержать конфиденциальную информацию

**Пример (WhisperService.swift:329):**
```swift
LogManager.transcription.success(
    "Транскрипция завершена",
    details: "\"\(correctedText)\" (\(String(format: "%.2f", transcriptionTime))s, RTF: \(String(format: "%.2f", rtf))x)"
)
```

**Рекомендации:**
```swift
// Создать режим конфиденциального логирования:
enum LogPrivacyLevel {
    case full       // Все данные
    case redacted   // Скрывать конфиденциальные данные
    case minimal    // Только критичные ошибки
}

class PrivacyAwareLogger {
    static var privacyLevel: LogPrivacyLevel = .redacted

    static func logTranscription(_ text: String, duration: TimeInterval, rtf: Double) {
        switch privacyLevel {
        case .full:
            LogManager.transcription.success(
                "Транскрипция завершена",
                details: "\"\(text)\" (\(duration)s, RTF: \(rtf)x)"
            )
        case .redacted:
            LogManager.transcription.success(
                "Транскрипция завершена",
                details: "[\(text.count) символов] (\(duration)s, RTF: \(rtf)x)"
            )
        case .minimal:
            LogManager.transcription.success("Транскрипция завершена")
        }
    }
}
```

---

## 10. Приоритизация задач рефакторинга

### Высокий приоритет (критично для качества кода)
1. **Dependency Injection** (раздел 1.2) - улучшит тестируемость
2. **Обработка ошибок** (раздел 3) - повысит надежность
3. **Разделение MainWindow** (раздел 1.1) - упростит поддержку

### Средний приоритет (улучшит архитектуру)
4. **Управление состоянием** (раздел 2) - упростит отладку
5. **Unit-тесты** (раздел 7.1) - повысит качество
6. **Рефакторинг длинных методов** (раздел 6.2) - улучшит читаемость

### Низкий приоритет (полировка кода)
7. **SwiftUI best practices** (раздел 5) - улучшит UI код
8. **Документация API** (раздел 8) - упростит онбординг
9. **Оптимизация производительности** (раздел 4) - при необходимости

---

## Заключение

TranscribeIt демонстрирует хорошую архитектурную основу для профессионального macOS приложения. Основные проблемы сосредоточены вокруг:

1. **Слабой типизации ошибок** - использование NSError вместо typed errors
2. **Жесткой связанности** - зависимость от синглтонов
3. **Недостаточного тестирования** - отсутствие unit-тестов
4. **Монолитных компонентов** - файлы >1000 строк

Реализация предложенных улучшений значительно повысит качество кода, упростит тестирование и поддержку проекта.
